âœ… 1. Funkcja print_action z uÅ¼yciem mutex (priorytet!)
Po co?

Do jednolitego drukowania komunikatÃ³w (np. "has taken a fork", "died", "is eating" itd.).

Chroni przed rozjechaniem siÄ™ outputu, gdy wielu filozofÃ³w drukuje jednoczeÅ›nie.

Nawet w przypadku jednego filozofa dobrze mieÄ‡ juÅ¼ gotowy system logowania.

Co musi przyjmowaÄ‡ ta funkcja?

Czas (timestamp)

Numer filozofa

TreÅ›Ä‡ komunikatu

WskaÅºnik na mutex do print

ğŸ’¡ To jest twoja "drukarka" â€” masz jÄ… raz zrobiÄ‡ porzÄ…dnie i korzystaÄ‡ zawsze.

âœ… 2. Funkcja do pobierania aktualnego czasu w ms (np. get_time_ms())
Po co?

BÄ™dziesz mierzyÄ‡ timestampy, np. kiedy filozof coÅ› zrobiÅ‚.

BÄ™dziesz teÅ¼ liczyÄ‡, ile czasu minÄ™Å‚o od startu.

Opiera siÄ™ na: gettimeofday.

âœ… 3. Zmienna start_time
Po co?

Potrzebna do tego, Å¼eby kaÅ¼dy komunikat byÅ‚ w formacie:
timestamp philosopher_number action

timestamp = current_time â€“ start_time

Gdzie jÄ… przechowujesz?

Albo w strukturze t_args

Albo globalnie (jeÅ›li dopuszczasz zmienne globalne â€“ choÄ‡ lepiej nie)

âœ… 4. Struktura t_philo (choÄ‡by tymczasowa)
Po co?

Å»eby mÃ³c przechowaÄ‡ dane jednego filozofa, np.:

id

args (wskaÅºnik do t_args)

start_time

print_mutex

Uwaga: Na razie moÅ¼e byÄ‡ tylko jeden filozof, ale jak jÄ… dobrze zrobisz, potem rozszerzenie do wielu to kwestia dodania pÄ™tli.

âœ… 5. Funkcja handle_one_philo()
To bÄ™dzie osobna funkcja, ktÃ³ra:

Tworzy jednego filozofa (t_philo)

WywoÅ‚uje print_action ("has taken a fork")

Czeka time_to_die

WywoÅ‚uje print_action ("died")

KoÅ„czy program

ğŸ” 6. (PÃ³Åºniej) OgÃ³lna pÄ™tla symulacji i routine()
Dopiero po tym, jak:

masz printy,

masz pomiar czasu,

masz jeden przypadek dziaÅ‚ajÄ…cy poprawnie,

wchodzisz w:

tworzenie filozofÃ³w (tablica t_philo)

tworzenie mutexÃ³w (widelce)

routine z while (1) dla filozofÃ³w


ogarnac te taski oraz obejrzec filmiki  o tym  aby dobrze sie przygotowac
zeby wszytsko zrozumiec 