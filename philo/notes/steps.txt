

ğŸŸ¥ 5. ğŸ’€ Monitor Å›mierci
Osobny wÄ…tek lub sprawdzanie w philo_routine
Regularnie sprawdza get_time() - last_meal_time > time_to_die
JeÅ›li ktoÅ› umiera:
Wypisz X died
Zablokuj inne wÄ…tki przed wypisywaniem

ZakoÅ„cz symulacjÄ™ (np. ustaw flagÄ™ all_alive = 0)

ğŸŸª 8. ğŸ§¹ Zwalnianie zasobÃ³w
pthread_join() lub pthread_detach() dla kaÅ¼dego filozofa

pthread_mutex_destroy() dla kaÅ¼dego mutexa

free() dla dynamicznie alokowanych struktur


| Etap | Nazwa                            | Gotowe? |
| ---- | -------------------------------- | ------- |
| 1    | Parsing i walidacja argumentÃ³w   | âœ…      |
| 2    | Inicjalizacja struktur i mutexÃ³w | âœ…      |
| 3    | Tworzenie wÄ…tkÃ³w filozofÃ³w       | âœ…      |
| 4    | GÅ‚Ã³wna pÄ™tla Å¼ycia filozofa      | âœ…      |
| 5    | Monitor Å›mierci                  | ğŸ”œ      |
| 6    | ObsÅ‚uga limitu jedzenia          | ğŸ”œ      |
| 7    | ObsÅ‚uga przypadku z 1 filozofem  | âœ…      |
| 8    | Zwalnianie zasobÃ³w               | ğŸ”œ      |
| 9    | Testy i norminette               | ğŸ”œ      |


â˜ ï¸ ETAP 3 â€“ MONITOROWANIE ÅšMIERCI
ğŸ“š Czego siÄ™ nauczyÄ‡:
gettimeofday() i liczenie czasu w ms

Synchronizacja z mutexem

Tworzenie osobnego wÄ…tku do monitorowania

âœ… Co zaimplementowaÄ‡:
WÄ…tek monitorujÄ…cy, ktÃ³ry:
Co kilka milisekund sprawdza current_time - last_meal.
JeÅ›li przekracza time_to_die, wypisuje X died i koÅ„czy program.
Zabezpieczenie przed wyÅ›cigiem danych (mutex przy odczycie last_meal).

ğŸ§ª ETAP 8 â€“ TESTOWANIE
âœ… Co przetestowaÄ‡:
bash
Copy
Edit
./philo 1 800 200 200            â†’ filozof umiera
./philo 5 800 200 200            â†’ Å¼aden nie umiera
./philo 4 310 200 100            â†’ jeden umrze
./philo 5 800 200 200 7          â†’ wszyscy zjedzÄ… po 7 razy, symulacja siÄ™ koÅ„czy
âœ… Inne testy:
SprawdÅº, czy nic siÄ™ nie wyÅ›wietla po Å›mierci filozofa.

SprawdÅº, czy nie ma Å›mieci w logach.

SprawdÅº, czy mutexy dziaÅ‚ajÄ… poprawnie (nie ma crashy, deadlockÃ³w).

