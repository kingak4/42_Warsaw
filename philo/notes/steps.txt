

🟥 5. 💀 Monitor śmierci
Osobny wątek lub sprawdzanie w philo_routine
Regularnie sprawdza get_time() - last_meal_time > time_to_die
Jeśli ktoś umiera:
Wypisz X died
Zablokuj inne wątki przed wypisywaniem

Zakończ symulację (np. ustaw flagę all_alive = 0)

🟪 8. 🧹 Zwalnianie zasobów
pthread_join() lub pthread_detach() dla każdego filozofa

pthread_mutex_destroy() dla każdego mutexa

free() dla dynamicznie alokowanych struktur


| Etap | Nazwa                            | Gotowe? |
| ---- | -------------------------------- | ------- |
| 1    | Parsing i walidacja argumentów   | ✅      |
| 2    | Inicjalizacja struktur i mutexów | ✅      |
| 3    | Tworzenie wątków filozofów       | ✅      |
| 4    | Główna pętla życia filozofa      | ✅      |
| 5    | Monitor śmierci                  | 🔜      |
| 6    | Obsługa limitu jedzenia          | 🔜      |
| 7    | Obsługa przypadku z 1 filozofem  | ✅      |
| 8    | Zwalnianie zasobów               | 🔜      |
| 9    | Testy i norminette               | 🔜      |


☠️ ETAP 3 – MONITOROWANIE ŚMIERCI
📚 Czego się nauczyć:
gettimeofday() i liczenie czasu w ms

Synchronizacja z mutexem

Tworzenie osobnego wątku do monitorowania

✅ Co zaimplementować:
Wątek monitorujący, który:
Co kilka milisekund sprawdza current_time - last_meal.
Jeśli przekracza time_to_die, wypisuje X died i kończy program.
Zabezpieczenie przed wyścigiem danych (mutex przy odczycie last_meal).

🧪 ETAP 8 – TESTOWANIE
✅ Co przetestować:
bash
Copy
Edit
./philo 1 800 200 200            → filozof umiera
./philo 5 800 200 200            → żaden nie umiera
./philo 4 310 200 100            → jeden umrze
./philo 5 800 200 200 7          → wszyscy zjedzą po 7 razy, symulacja się kończy
✅ Inne testy:
Sprawdź, czy nic się nie wyświetla po śmierci filozofa.

Sprawdź, czy nie ma śmieci w logach.

Sprawdź, czy mutexy działają poprawnie (nie ma crashy, deadlocków).

