âœ… Etapy projektu philo â€“ checklista do wdroÅ¼enia (w kolejnoÅ›ci logicznej)
ğŸŸ© 1. âœ… Parsowanie argumentÃ³w (juÅ¼ masz)
ObsÅ‚uga 4â€“5 argumentÃ³w wejÅ›ciowych

Konwersja char **argv na int (lub long do walidacji)

Walidacja danych: liczby dodatnie, brak nadmiarowych znakÃ³w, limity

Zapis do struktury t_args

ğŸŸ¨ 2. ğŸ”’ Inicjalizacja struktury gÅ‚Ã³wnej
Musisz stworzyÄ‡ i przygotowaÄ‡:

t_philo â€“ dane kaÅ¼dego filozofa (numer, licznik posiÅ‚kÃ³w, czas ostatniego posiÅ‚ku, mutex do wÅ‚asnego "czasu ostatniego posiÅ‚ku")

t_fork lub pthread_mutex_t *forks â€“ mutexy do widelcÃ³w

pthread_mutex_t print_mutex â€“ do synchronizacji wypisywania

pthread_mutex_t death_mutex â€“ do ochrony informacji o Å›mierci

long start_time â€“ punkt startowy symulacji

(opcjonalnie) inne pola â€“ np. all_alive, must_eat_count

ğŸŸ¨ 3. ğŸ§µ Tworzenie wÄ…tkÃ³w (pthread)
Dla kaÅ¼dego filozofa utwÃ³rz osobny wÄ…tek pthread_create

WÄ…tki bÄ™dÄ… wykonywaÄ‡ gÅ‚Ã³wnÄ… funkcjÄ™ symulacyjnÄ… philo_routine

Upewnij siÄ™, Å¼e kaÅ¼dy filozof otrzymuje swojÄ… wÅ‚asnÄ… kopiÄ™ danych

ğŸŸ¦ 4. ğŸ” Funkcja gÅ‚Ã³wna filozofa (ruchy)
W philo_routine zrÃ³b pÄ™tlÄ™:

MyÅ›lenie

Branie widelcÃ³w (mutex_lock)

Jedzenie (czas + aktualizacja czasu ostatniego posiÅ‚ku)

OdkÅ‚adanie widelcÃ³w (mutex_unlock)

Spanie (usleep)

Loguj wszystko z zachowaniem synchronizacji.

ğŸŸ¥ 5. ğŸ’€ Monitor Å›mierci
Osobny wÄ…tek lub sprawdzanie w philo_routine

Regularnie sprawdza get_time() - last_meal_time > time_to_die

JeÅ›li ktoÅ› umiera:

Wypisz X died

Zablokuj inne wÄ…tki przed wypisywaniem

ZakoÅ„cz symulacjÄ™ (np. ustaw flagÄ™ all_alive = 0)

ğŸŸ¨ 6. ğŸ ObsÅ‚uga limitu jedzenia
JeÅ›li przekazany 5. argument:

KaÅ¼dy filozof musi zjeÅ›Ä‡ N razy

JeÅ›li wszyscy zjedli â€“ koÅ„cz symulacjÄ™ (np. philos_fed++)

Musisz to bezpiecznie zliczaÄ‡ (mutex do zmiennej globalnej)

ğŸŸ§ 7. ğŸ¥„ ObsÅ‚uga przypadku z 1 filozofem
Filozof nie moÅ¼e nigdy zjeÅ›Ä‡ â€“ umiera po time_to_die

Ten przypadek musisz obsÅ‚uÅ¼yÄ‡ osobno (bez wchodzenia w gÅ‚Ã³wnÄ… pÄ™tlÄ™)

ğŸŸª 8. ğŸ§¹ Zwalnianie zasobÃ³w
pthread_join() lub pthread_detach() dla kaÅ¼dego filozofa

pthread_mutex_destroy() dla kaÅ¼dego mutexa

free() dla dynamicznie alokowanych struktur


| Etap | Nazwa                            | Gotowe? |
| ---- | -------------------------------- | ------- |
| 1    | Parsing i walidacja argumentÃ³w   | âœ…      |
| 2    | Inicjalizacja struktur i mutexÃ³w | ğŸ”œ      |
| 3    | Tworzenie wÄ…tkÃ³w filozofÃ³w       | ğŸ”œ      |
| 4    | GÅ‚Ã³wna pÄ™tla Å¼ycia filozofa      | ğŸ”œ      |
| 5    | Monitor Å›mierci                  | ğŸ”œ      |
| 6    | ObsÅ‚uga limitu jedzenia          | ğŸ”œ      |
| 7    | ObsÅ‚uga przypadku z 1 filozofem  | ğŸ”œ      |
| 8    | Zwalnianie zasobÃ³w               | ğŸ”œ      |
| 9    | Testy i norminette               | ğŸ”œ      |

ğŸ§± ETAP 1 â€“ STRUKTURY I INICJALIZACJA
ğŸ“š Czego siÄ™ nauczyÄ‡:
Jak dziaÅ‚ajÄ… pthread_t i pthread_mutex_t.

Jak dziaÅ‚ajÄ… struct, malloc, free.

âœ… Co zaimplementowaÄ‡:
Struktury:

t_args: przechowuje dane z argumentÃ³w.

t_philo: dane o filozofie (numer, mutexy, licznik jedzenia, wskaÅºnik do args, czas ostatniego posiÅ‚ku itd.).

t_data: dane gÅ‚Ã³wne (mutexy, start_time, tablica filozofÃ³w).

Inicjalizacja:

Alokacja tablicy filozofÃ³w.

Tworzenie mutexÃ³w do widelcÃ³w.

Przypisanie lewej i prawej rÄ™ki dla kaÅ¼dego filozofa.

ğŸ ETAP 2 â€“ TWORZENIE WÄ„TKÃ“W FILOZOFÃ“W
ğŸ“š Czego siÄ™ nauczyÄ‡:
pthread_create, pthread_join, pthread_detach

Jak przekazywaÄ‡ argumenty do wÄ…tku

âœ… Co zaimplementowaÄ‡:
KaÅ¼dy filozof = osobny wÄ…tek.

WÄ…tek filozofa wykonuje funkcjÄ™, np. routine(void *arg), ktÃ³ra:

Zaczyna od myÅ›lenia.

Bierze dwa widelce (mutex_lock).

Je (usleep), zapisuje last_meal.

OdkÅ‚ada widelce (mutex_unlock).

Åšpi (usleep).

MyÅ›li i wraca na poczÄ…tek pÄ™tli.

â˜ ï¸ ETAP 3 â€“ MONITOROWANIE ÅšMIERCI
ğŸ“š Czego siÄ™ nauczyÄ‡:
gettimeofday() i liczenie czasu w ms

Synchronizacja z mutexem

Tworzenie osobnego wÄ…tku do monitorowania

âœ… Co zaimplementowaÄ‡:
WÄ…tek monitorujÄ…cy, ktÃ³ry:

Co kilka milisekund sprawdza current_time - last_meal.

JeÅ›li przekracza time_to_die, wypisuje X died i koÅ„czy program.

Zabezpieczenie przed wyÅ›cigiem danych (mutex przy odczycie last_meal).

ğŸ¥„ ETAP 4 â€“ WIDELCE (MUTEXY)
ğŸ“š Czego siÄ™ nauczyÄ‡:
pthread_mutex_lock / pthread_mutex_unlock

Blokowanie zasobÃ³w

âœ… Co zaimplementowaÄ‡:
KaÅ¼dy widelec to mutex.

Filozof najpierw blokuje jeden widelec, potem drugi.

Zadbaj o kolejnoÅ›Ä‡ blokowania:

Parzysty filozof: lewy â†’ prawy

Nieparzysty: prawy â†’ lewy

DziÄ™ki temu unikasz zakleszczenia (deadlock)

ğŸ“ ETAP 5 â€“ WYDRUK ZDARZEÅƒ (SYNCHRONIZACJA PRINT)
ğŸ“š Czego siÄ™ nauczyÄ‡:
Jak unikaÄ‡ mieszania siÄ™ printf w wielu wÄ…tkach

âœ… Co zaimplementowaÄ‡:
Jeden mutex do drukowania.

Wszystkie printf() zawijaj w mutex_lock(print) i mutex_unlock(print).

ğŸ§â€â™‚ï¸ ETAP 6 â€“ PRZYPADKI SZCZEGÃ“LNE
ğŸ“š Czego siÄ™ nauczyÄ‡:
Jak dziaÅ‚a zachowanie filozofa z jednym widelcem

Jak koÅ„czyÄ‡ program

âœ… Co zaimplementowaÄ‡:
Przypadek: 1 filozof

Powinien podnieÅ›Ä‡ 1 widelec i umrzeÄ‡ po time_to_die.

ZakoÅ„czenie programu:

JeÅ›li podany jest number_of_times_each_philosopher_must_eat, to gdy wszyscy tyle razy zjedzÄ…, koÅ„czysz symulacjÄ™.

ğŸ§¹ ETAP 7 â€“ SPRZÄ„TANIE
ğŸ“š Czego siÄ™ nauczyÄ‡:
pthread_mutex_destroy

free

âœ… Co zaimplementowaÄ‡:
Zwolnij wszystkie mutexy.

Zwolnij pamiÄ™Ä‡.

Upewnij siÄ™, Å¼e nie ma memory leaks ani zombie threads.

ğŸ§ª ETAP 8 â€“ TESTOWANIE
âœ… Co przetestowaÄ‡:
bash
Copy
Edit
./philo 1 800 200 200            â†’ filozof umiera
./philo 5 800 200 200            â†’ Å¼aden nie umiera
./philo 4 310 200 100            â†’ jeden umrze
./philo 5 800 200 200 7          â†’ wszyscy zjedzÄ… po 7 razy, symulacja siÄ™ koÅ„czy
âœ… Inne testy:
SprawdÅº, czy nic siÄ™ nie wyÅ›wietla po Å›mierci filozofa.

SprawdÅº, czy nie ma Å›mieci w logach.

SprawdÅº, czy mutexy dziaÅ‚ajÄ… poprawnie (nie ma crashy, deadlockÃ³w).

